/* eslint-disable */
/* tslint:disable */
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */

export interface UpdatePersonalDetails {
    name?: string;
    email?: string;
}

export interface PaymentIntent {
    /**
     * Secret token generated by the payment provider
     * @example "asdasdasd12e1eqd"
     */
    paymentToken?: string;
    /**
     * ID of the payment intent in badger commerce
     * @example "asdd123cafdf"
     */
    id?: string;
    /**
     * Third party payment ID for the payment intent
     * @example "test_123123ksdf"
     */
    thirdPartyId?: string;
    /** Amount in base currency requested with this intent */
    amountRequested?: number;
    /** Amount in base currency captured with this intent */
    amountCaptured?: number;
    /** Amount in base currency authorised with this intent */
    amountAuthorised?: number;
    /** Amount in base currency refunded with this intent */
    amountRefunded?: number;
    /** Status of the payment intent in the system */
    status?: string;
    /** type of payment method */
    paymentType?: PaymentType;
}

/**
 * type of payment method
 * @example "card"
 */
export enum PaymentType {
    CardNotPresent = "card_not_present",
    CardPresent = "card_present",
    Giftcard = "giftcard",
}

export interface PaymentToken {
    /**
     * token used to authorise the payment device attached to the POS
     * @example "askdb12oeno13n4"
     */
    tokenId?: string;
}

export interface CreateBasketRequest {
    basketItems: AddToBasketRequest[];
    /**
     * Promo code to apply to the order
     * @example "10PC_OFF"
     */
    promotionCode?: string;
    /**
     * An optional date representing when the order was placed, used to calculate prices and promotions (e.g. historical repricing)
     * @format date-time
     */
    calculationDate?: string;
}

export interface AddToBasketRequest {
    /**
     * skuId of the item or variant to add to the basket
     * @example "sku123"
     */
    skuId?: string;
    /**
     * number of items to add to the basket
     * @example 10
     */
    quantity?: number;
}

export interface User {
    /**
     * unique id of the user
     * @example "19283981273"
     */
    id?: string;
    /**
     * User's email address
     * @example "test@test.com"
     */
    email?: string;
    /**
     * registration date/time
     * @format date-time
     * @example "01-01-2000 12:32:10"
     */
    registrationTime?: string;
    personalDetails?: PersonalDetails;
    /**
     * indicates whether the account is linked to valid login credentials or is anonymous
     * @example true
     */
    anonymous?: boolean;
    /**
     * Indicates that the email address has been verified for this customer
     * @example true
     */
    emailAddressVerified?: boolean;
    /**
     * image of the user (from the IDP)
     * @example "https://s.gravatar.com/avatar/4095b9a7bada3463e724f6c35014fb17?s=80"
     */
    picture?: string;
    /**
     * issuer of the token
     * @example "google"
     */
    issuer?: string;
}

export interface PersonalDetails {
    /**
     * Honourary prefix
     * @example "Mr"
     */
    title?: string;
    /**
     * First Name
     * @example "Jim"
     */
    firstName?: string;
    /**
     * Last name/Surname
     * @example "Badgerton"
     */
    lastName?: string;
    /**
     * User's date of birtth
     * @format date
     * @example "01-01-2000"
     */
    dateOfBirth?: string;
    /** Additional phone numbers with identifying key */
    otherPhoneNumbers?: Record<string, any>;
    /**
     * Customer's mobile phone number
     * @example "07123456789"
     */
    mobilePhoneNumber?: string;
    /**
     * Customer's email address
     * @example "bob@bobbingtons.com"
     */
    emailAddress?: string;
    /**
     * ID of the delivery address that is set as the default for the customer
     * @example "abc123"
     */
    defaultDeliveryAddressId?: string;
    /**
     * ID of the billing address that is set as the default for the customer
     * @example "abc123"
     */
    defaultBillingAddressId?: string;
}

export interface Product {
    /**
     * unique id of the product
     * @example "19283981273"
     */
    id?: string;
    /**
     * the ID of the catalogue
     * @example "defaultCatalogue"
     */
    catalogueId?: string;
    /**
     * SKU ID of the product
     * @example 123123
     */
    skuId?: string;
    /**
     * The display name of the product
     * @example "Badger T-Shirt"
     */
    name?: string;
    /**
     * Long description of the product
     * @example "A very nice t-shirt made from the highest quality materials"
     */
    description?: string;
    /**
     * A shortened description of the product
     * @example "The best t-shirt"
     */
    miniDescription?: string;
    /** Media items associated with the product */
    media?: MediaItem[];
    /**
     * Base price of the product in smallest denomination (e.g. pence/cent)
     * @example 100
     */
    basePrice?: number;
    /**
     * Base comparison price for slash-pricing in smallest denomination
     * @example 120
     */
    comparePrice?: number;
    /**
     * Name of the brand that makes the product - may be displayed on the lising and product pages.
     * @example "Badgertons"
     */
    manufacturer?: string;
    /**
     * The use friendly, unique, name for the product, usually used in the URL of the product.
     * @example "badger-t-shirt"
     */
    seoName?: string;
    /**
     * The review score for the product
     * @example 4
     */
    rating?: number;
    /**
     * IDs of the parent collections that this product belongs to
     * @example [1123,123123]
     */
    collectionIDs?: string[];
    /** Product attribute map */
    attributes?: object;
    /**
     * Date the item was publshed onto the live site
     * @format date-time
     */
    publishedDate?: string;
    /**
     * Date the item was created
     * @format date-time
     */
    createdDate?: string;
    /** Flag indicating whether the product requires shipping */
    shippingRequired?: boolean;
    /** A set of unique type descriptors identifying the capabilities/requirements for the product */
    typeDecorators?: string[];
    /** indicates that this is not a product that can be purchased, instead there are variants beneath this which must be purchased. */
    hasVariants?: boolean;
    /** Optional data associated with the product for inclusion on the page. */
    extensionData?: ExtensionEntry[];
    /** Mapping of tax codes to locales that apply to this product */
    taxCodes?: TaxCodeLocales[];
    /** Weight measurements for the product */
    weights?: Weight[];
    /** Dimension measurements for the product */
    dimensions?: Dimension[];
    /**
     * UPC of the product
     * @example 912093847124
     */
    upc?: string;
}

export interface Weight {
    /**
     * Weight in grams
     * @example 12.3
     */
    weight?: number;
    measurementType?: MeasurementType;
}

export interface Dimension {
    /**
     * Length in cm in the x dimension
     * @example 12.3
     */
    x?: number;
    /**
     * Length in cm in the y dimension
     * @example 12.3
     */
    y?: number;
    /**
     * Length in cm in the z dimension
     * @example 12.3
     */
    z?: number;
    measurementType?: MeasurementType;
}

export enum MeasurementType {
    ITEM = "ITEM",
    PACK = "PACK",
    PALLET = "PALLET",
    CRATE = "CRATE",
    CONTAINER = "CONTAINER",
}

export interface TaxCodeLocales {
    /**
     * Locale code
     * @format locale
     * @example "en_GB"
     */
    locale?: string;
    /**
     * Badger tax code that should be used for calculation
     * @example "internalStandardVAT"
     */
    taxCode?: string;
}

export interface MediaItem {
    /** ID of the media item within the system */
    id?: string;
    /** Main image URL */
    url?: string;
    /** Thumbnail image URL */
    thumbnailURL?: string;
    /** Image title */
    title?: string;
    /** Alternate text to display if the image is missing or for screen readers */
    altText?: string;
}

export interface OrderSearchResults {
    orders?: Order[];
    /** Number of results found in the DB for this query */
    resultCount?: number;
}

export interface Order {
    /**
     * Order ID
     * @example "12833rgu2i4gi234523o4h"
     */
    id?: string;
    /**
     * Friendly order number (human readable)
     * @example 1001
     */
    number?: string;
    /** Set of actions that can be performed on the order to move it through the life-cycle. */
    nextActions?: OrderAction[];
    /**
     * Date the item was created
     * @format date-time
     */
    createdDate?: string;
    /**
     * Date the order was submitted
     * @format date-time
     */
    submittedDate?: string;
    /**
     * Date the item was last updated
     * @format date-time
     */
    lastUpdatedDate?: string;
    /** indicates whether the order is currently being repriced and therefore not consistent */
    repricing?: boolean;
    /** secret code proving ownership of the order in non-authenticated contexts (e.g. deeplinks) */
    confirmationCode?: string;
    /**
     * current state of the order
     * @example "initial"
     */
    state?: string;
    price?: Price;
    personalDetails?: PersonalDetails;
    paymentDetails?: PaymentDetails;
    shippingAddress?: Address;
    billingAddress?: Address;
    /** Line items representing the contents of the order */
    lineItems?: LineItem[];
}

export interface OrderAction {
    /** Action code identifying what action can be performed on the order */
    code?: string;
    /** Describes the detail of the action that can be performed */
    description?: string;
}

export interface Price {
    /** ISO Currency code of the price (e.g. GBP, USD, EUR) */
    currencyCode?: string;
    /**
     * Total price of the item (including taxes, fees, discounts etc)
     * @format int32
     */
    total?: number;
    /**
     * Net price of the item (excluding taxes, fees, etc)
     * @format int32
     */
    net?: number;
    /**
     * Amount of tax calculated for the item
     * @format int32
     */
    tax?: number;
    /** details of the sources of the tax for this item */
    taxSources?: PriceAlterationDetails[];
    /**
     * Total amount of additional fees charged on the item
     * @format int32
     */
    fee?: number;
    /** details of the sources of the fees for this item */
    feeSources?: PriceAlterationDetails[];
    /**
     * Total amount of additional application/platform fees charged on the item
     * @format int32
     */
    applicationFee?: number;
    /** details of the sources of the application/platform fees for this item */
    applicationFeeSources?: PriceAlterationDetails[];
    /**
     * Total amount of discount applied to the item
     * @format int32
     */
    discount?: number;
    /** details of the sources of the discounts for this item */
    discountSources?: PriceAlterationDetails[];
}

export interface PriceAlterationDetails {
    /**
     * Total amount of alteration applied
     * @format int32
     */
    amount?: number;
    /**
     * Total percentage of alteration applied
     * @format double
     */
    percentage?: number;
    /**
     * Date that this price alteration was applied
     * @format date-time
     */
    dateApplied?: string;
    /** Code representing the source of this alteration */
    code?: string;
    /** human-readable description of the alteration */
    description?: string;
}

export interface PaymentDetails {
    /** Token representing the payment method in the external payment system */
    token?: string;
    /** Auth token for the token (respresenting an approved auth of the card in the external system) */
    authorisationToken?: string;
    /** ISO currency code for the payment */
    currencyCode?: string;
    /** state of the payment */
    state?: string;
    /** shows whether this is a live payment or test */
    liveMode?: boolean;
    /**
     * Total amount of payment
     * @format int32
     */
    amount?: number;
    /**
     * Total amount of platform/application fee
     * @format int32
     */
    applicationFee?: number;
    cardDetails?: CardDetails;
}

export interface CardDetails {
    /** @format int32 */
    expMonth?: number;
    /** @format int32 */
    expYear?: number;
    last4?: string;
    country?: string;
    type?: string;
    name?: string;
    id?: string;
    customer?: string;
    recipient?: string;
    addressLine1?: string;
    addressLine2?: string;
    addressZip?: string;
    addressCity?: string;
    addressState?: string;
    addressCountry?: string;
    addressZipCheck?: string;
    addressLine1Check?: string;
    cvcCheck?: string;
    fingerprint?: string;
    brand?: string;
    funding?: string;
}

export interface Address {
    /** Name of the person at the address */
    name?: string;
    /** First line of the address */
    line1?: string;
    /** Second line of the address */
    line2?: string;
    /** Third line of the address */
    line3?: string;
    /** Fourth line of the address */
    line4?: string;
    /** City/Town of the address */
    city?: string;
    /** Region or county of the address */
    regionCounty?: string;
    /** State or sub-country of the address */
    state?: string;
    /** Country of the address */
    country?: string;
    /** Postal/zip code of the address */
    postalCode?: string;
    /** Instructions for the delivery */
    deliveryInstructions?: string;
    /** What Three Words location code for the address */
    whatThreeWords?: string;
    /** latitude of the address */
    latitude?: number;
    /** longitude of the address */
    longitude?: number;
}

export interface LineItem {
    /** internal ID of the line item (used to allow modifications) */
    id?: string;
    /** SKU ID of the Product represented by the line item. */
    productSkuId?: string;
    /** optional SKU ID of the variant of the product that the line item represents */
    variantSkuId?: string;
    /**
     * single item price of the product represented by this line item
     * @format int32
     */
    itemPrice?: number;
    price?: Price;
    /**
     * number of items in the line item
     * @format int32
     */
    quantity?: number;
    /** indicates that the line item requires shipment for fulfilment */
    requiresShipment?: boolean;
    /**
     * TBC
     * @format int32
     */
    shippingCategoryCode?: number;
    /** various fulfilment attributes as required for each product type */
    attributes?: Record<string, string>;
    /** set of productTypeDescriptors that apply to this line item */
    productTypeDecorators?: string[];
    productDetails?: Product;
}

export interface SiteContext {
    /**
     * The name of the site
     * @example "Test Site"
     */
    siteName?: string;
    /**
     * Internal ID of the site
     * @example "default"
     */
    siteId?: string;
    /** The primary domain for the site */
    domainURL?: string;
    /** Other domain names that the site will respond to */
    otherDomains?: string[];
    /** True if the site should not redirect requests matched on other domains to the primary domain.  Should usually be false as it's bad for SEO to serve the same content on multiple URLs */
    preventRedirectOfOtherDomains?: boolean;
    /**
     * ID of the current live catalogue
     * @example "default"
     */
    catalogueId?: string;
    /** The ID of the previously live catalouge */
    lastLiveCatalougeId?: string;
    /**
     * the default locale the site should use
     * @example "en_GB"
     */
    defaultLocale?: string;
    /**
     * The URL prefix that the media items within the catalogue are located at (should be prefixed on the URLs supplied in the other APIs)
     * @example "https://test.cloudfront.net/"
     */
    mediaPath?: string;
    /**
     * The URL to the main logo to be used with the theme
     * @format url
     */
    logoURL?: string;
    /** Map of the social accounts that belong to the site */
    socialAccounts?: Record<string, string>;
}

export interface MenuNode {
    /**
     * ID of the menu Node
     * @example 123
     */
    id?: string;
    /**
     * Slug identifying the node within the hierarchy
     * @example "clothing"
     */
    nodeId?: string;
    childNodeIds?: string[];
    /**
     * The text displayed in for the link to the end users
     * @example true
     */
    linkedText?: string;
    /** Indicates that the link should only be displayed to authenticated users */
    loggedInOnly?: boolean;
    downwardLink?: DownwardLink;
}

export interface DownwardLink {
    /** ID of the component linked to - e.g. product, collection or page */
    linkedId?: string;
    linkType?: "PAGE" | "COLLECTION" | "PRODUCT" | "EXTERNAL_URL" | "PRODUCT_ATB";
    /** Indicates whether the tree should be traversed in a set of pages or collection */
    traverseTree?: boolean;
    /** Determines how deep to go within a collection or page tree */
    traversalDepth?: number;
    /** Number of items to retrieve from the linked type - e.g. 10 products, 20 collections, etc */
    batchSize?: number;
    /** External URL that the link links to */
    externalURL?: string;
}

export interface DisplayMenuNode {
    /**
     * ID of the menu Node
     * @example 123
     */
    id?: string;
    /**
     * Link text displayed to the end user
     * @example "T-Shirts"
     */
    text?: string;
    /**
     * URL or SKU ID that the link should go to/add
     * @format url
     * @example "/t-shirts"
     */
    resource?: string;
    /**
     * Indicates that the link should open a new window
     * @example true
     */
    newWindow?: boolean;
    /** Indicates what type of link this is, to determine the behaviour required from the UI */
    linkType?: "internal" | "external" | "addToBasket";
    childNodes?: DisplayMenuNode[];
}

export interface Collection {
    /**
     * ID of the collection in the data store
     * @example 123123123
     */
    id?: string;
    /**
     * The display name of the collection
     * @example "T-Shirts"
     */
    name?: string;
    /**
     * The unique code used in the URL to identify the collection
     * @example "tshirts"
     */
    seoName?: string;
    /**
     * A short description of the collection
     * @example "Awesome T-Shirts for sale, get them now!"
     */
    description?: string;
    /**
     * The name of the template that is should be used to display this collection
     * @example "superTemplate1"
     */
    templateName?: string;
    /**
     * Indicates whether this particular collection has been disabled
     * @example false
     */
    disabled?: boolean;
    /** List of collection IDs that are the parent collections of this collection. */
    parentCollectionIDs?: string[];
    /**
     * base sorting ordinal - larger numbers are displayed first when collections are shown in a list
     * @example 500
     */
    displayOrder?: number;
    /** Optional data associated with the product for inclusion on the page. */
    extensionData?: ExtensionEntry[];
}

export interface ExtensionPayload {
    /**
     * The code that identifies the extension rendering component that should handle this particular payload
     * @example "uk.co.kedos.badger.product.recommendations.v1"
     */
    componentReference: string;
    [key: string]: any;
}

export interface ExtensionEntry {
    /** The name of the slot on the page where this collection of extensions should live */
    pageSlotName: string;
    payloads?: ExtensionPayload[];
}

export type ExtensionUpdateBody = Record<string, any>;

export interface DuplicateIdentifierError {
    /**
     * The identifier that has a duplicate
     * @example "skuId"
     */
    identifierName?: string;
}

export interface ModifyLineItemBody {
    /**
     * The new quantity for the item
     * @example 5
     */
    quantity?: number;
}

import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, HeadersDefaults, ResponseType } from "axios";

export type QueryParamsType = Record<string | number, any>;

export interface FullRequestParams extends Omit<AxiosRequestConfig, "data" | "params" | "url" | "responseType"> {
    /** set parameter to `true` for call `securityWorker` for this request */
    secure?: boolean;
    /** request path */
    path: string;
    /** content type of request body */
    type?: ContentType;
    /** query params */
    query?: QueryParamsType;
    /** format of response (i.e. response.json() -> format: "json") */
    format?: ResponseType;
    /** request body */
    body?: unknown;
}

export type RequestParams = Omit<FullRequestParams, "body" | "method" | "query" | "path">;

export interface ApiConfig<SecurityDataType = unknown> extends Omit<AxiosRequestConfig, "data" | "cancelToken"> {
    securityWorker?: (securityData: SecurityDataType | null) => Promise<AxiosRequestConfig | void> | AxiosRequestConfig | void;
    secure?: boolean;
    format?: ResponseType;
}

export enum ContentType {
    Json = "application/json",
    FormData = "multipart/form-data",
    UrlEncoded = "application/x-www-form-urlencoded",
    Text = "text/plain",
}

export class HttpClient<SecurityDataType = unknown> {
    public instance: AxiosInstance;
    private securityData: SecurityDataType | null = null;
    private securityWorker?: ApiConfig<SecurityDataType>["securityWorker"];
    private secure?: boolean;
    private format?: ResponseType;

    constructor({ securityWorker, secure, format, ...axiosConfig }: ApiConfig<SecurityDataType> = {}) {
        this.instance = axios.create({
            ...axiosConfig,
            baseURL: axiosConfig.baseURL || "https://virtserver.swaggerhub.com/Kedos-Consulting-Ltd/badger-commerce-api/1.0.0",
        });
        this.secure = secure;
        this.format = format;
        this.securityWorker = securityWorker;
    }

    public setSecurityData = (data: SecurityDataType | null) => {
        this.securityData = data;
    };

    protected mergeRequestParams(params1: AxiosRequestConfig, params2?: AxiosRequestConfig): AxiosRequestConfig {
        const method = params1.method || (params2 && params2.method);

        return {
            ...this.instance.defaults,
            ...params1,
            ...(params2 || {}),
            headers: {
                ...((method && this.instance.defaults.headers[method.toLowerCase() as keyof HeadersDefaults]) || {}),
                ...(params1.headers || {}),
                ...((params2 && params2.headers) || {}),
            },
        };
    }

    protected stringifyFormItem(formItem: unknown) {
        if (typeof formItem === "object" && formItem !== null) {
            return JSON.stringify(formItem);
        } else {
            return `${formItem}`;
        }
    }

    protected createFormData(input: Record<string, unknown>): FormData {
        return Object.keys(input || {}).reduce((formData, key) => {
            const property = input[key];
            const propertyContent: any[] = property instanceof Array ? property : [property];

            for (const formItem of propertyContent) {
                const isFileType = formItem instanceof Blob || formItem instanceof File;
                formData.append(key, isFileType ? formItem : this.stringifyFormItem(formItem));
            }

            return formData;
        }, new FormData());
    }

    public request = async <T = any, _E = any>({ secure, path, type, query, format, body, ...params }: FullRequestParams): Promise<AxiosResponse<T>> => {
        const secureParams =
            ((typeof secure === "boolean" ? secure : this.secure) && this.securityWorker && (await this.securityWorker(this.securityData))) || {};
        const requestParams = this.mergeRequestParams(params, secureParams);
        const responseFormat = format || this.format || undefined;

        if (type === ContentType.FormData && body && body !== null && typeof body === "object") {
            body = this.createFormData(body as Record<string, unknown>);
        }

        if (type === ContentType.Text && body && body !== null && typeof body !== "string") {
            body = JSON.stringify(body);
        }

        return this.instance.request({
            ...requestParams,
            headers: {
                ...(requestParams.headers || {}),
                ...(type && type !== ContentType.FormData ? { "Content-Type": type } : {}),
            },
            params: query,
            responseType: responseFormat,
            data: body,
            url: path,
        });
    };
}

/**
 * @title Badger Commerce API
 * @version 1.0.0
 * @baseUrl https://virtserver.swaggerhub.com/Kedos-Consulting-Ltd/badger-commerce-api/1.0.0
 *
 * API specification for the Badger Commerce Engine
 */
export class Api<SecurityDataType extends unknown> extends HttpClient<SecurityDataType> {
    v1 = {
        /**
         * @description Fetches the site context from the data store for the site that maps to the current URL/context.
         *
         * @tags Site
         * @name GetSiteContext
         * @summary Get SiteContext data about the current site
         * @request GET:/v1/public/site
         */
        getSiteContext: (params: RequestParams = {}) =>
            this.request<SiteContext, void>({
                path: `/v1/public/site`,
                method: "GET",
                format: "json",
                ...params,
            }),

        /**
         * @description Fetches the default menu hierarchy from the data store for the site that maps to the current URL/context.
         *
         * @tags Site
         * @name GetMenu
         * @summary Gets the default display menu structure
         * @request GET:/v1/public/site/menu
         */
        getMenu: (params: RequestParams = {}) =>
            this.request<DisplayMenuNode[], void>({
                path: `/v1/public/site/menu`,
                method: "GET",
                format: "json",
                ...params,
            }),

        /**
         * No description
         *
         * @tags Menu
         * @name CreateMenuNode
         * @summary Creates a Menu node
         * @request POST:/v1/admin/menu
         */
        createMenuNode: (data: MenuNode, params: RequestParams = {}) =>
            this.request<MenuNode, any>({
                path: `/v1/admin/menu`,
                method: "POST",
                body: data,
                type: ContentType.Json,
                format: "json",
                ...params,
            }),

        /**
         * No description
         *
         * @tags Menu
         * @name GetMenuNodes
         * @summary Gets a list of Menu nodes from the repository
         * @request GET:/v1/admin/menu
         */
        getMenuNodes: (
            query?: {
                /** Only fetch top level menu nodes */
                topLevelOnly?: boolean;
                /**
                 * The number of results to return in a page. If it isn't specified then a configured default will be returned.
                 * @example 20
                 */
                pageSize?: number;
                /**
                 * The page of results to be returned, with a 0-based index (i.e. the first page is page 0, then page 1, 2, etc.).  Defaults to 0 if not supplied.
                 * @example 0
                 */
                pageNumber?: number;
            },
            params: RequestParams = {}
        ) =>
            this.request<MenuNode[], any>({
                path: `/v1/admin/menu`,
                method: "GET",
                query: query,
                format: "json",
                ...params,
            }),

        /**
         * No description
         *
         * @tags Menu
         * @name GetMenuNodeById
         * @summary Gets a menu node by its ID
         * @request GET:/v1/admin/menu/{id}
         */
        getMenuNodeById: (id: string, params: RequestParams = {}) =>
            this.request<MenuNode, void>({
                path: `/v1/admin/menu/${id}`,
                method: "GET",
                format: "json",
                ...params,
            }),

        /**
         * No description
         *
         * @tags Menu
         * @name UpdateMenuNodeById
         * @summary Updates a menu node by its ID
         * @request PUT:/v1/admin/menu/{id}
         */
        updateMenuNodeById: (id: string, data: MenuNode, params: RequestParams = {}) =>
            this.request<void, void>({
                path: `/v1/admin/menu/${id}`,
                method: "PUT",
                body: data,
                type: ContentType.Json,
                ...params,
            }),

        /**
         * No description
         *
         * @tags Menu
         * @name DeleteMenuNodeById
         * @summary Deletes a menu node by its ID
         * @request DELETE:/v1/admin/menu/{id}
         */
        deleteMenuNodeById: (id: string, params: RequestParams = {}) =>
            this.request<void, void>({
                path: `/v1/admin/menu/${id}`,
                method: "DELETE",
                ...params,
            }),

        /**
         * @description Fetches the menu hierarchy from the data store for the site that maps to the current URL/context.
         *
         * @tags Site
         * @name GetMenuByRootNodeId
         * @summary Gets a menu structure by the root ID
         * @request GET:/v1/public/site/menu/{rootNodeId}
         */
        getMenuByRootNodeId: (rootNodeId: string, params: RequestParams = {}) =>
            this.request<MenuNode[], void>({
                path: `/v1/public/site/menu/${rootNodeId}`,
                method: "GET",
                format: "json",
                ...params,
            }),

        /**
         * @description Fetches the category specified by the ID for the current store.
         *
         * @tags Collections
         * @name GetCollection
         * @summary Get a collection/category
         * @request GET:/v1/public/collection/{id}
         */
        getCollection: (
            id: string,
            query?: {
                /** @example true */
                generateExtensions?: boolean;
            },
            params: RequestParams = {}
        ) =>
            this.request<Collection, void>({
                path: `/v1/public/collection/${id}`,
                method: "GET",
                query: query,
                format: "json",
                ...params,
            }),

        /**
         * @description Fetches the category specified by the ID for the current store.
         *
         * @tags Collections
         * @name HandleCollectionExtensionById
         * @summary Get a collection/category
         * @request GET:/v1/public/collection/{id}/extension/{extensionId}
         */
        handleCollectionExtensionById: (id: string, extensionId: string, params: RequestParams = {}) =>
            this.request<Collection, void>({
                path: `/v1/public/collection/${id}/extension/${extensionId}`,
                method: "GET",
                format: "json",
                ...params,
            }),

        /**
         * @description Searches the catalogue for a collection with a matching SEO name/code.
         *
         * @tags Collections
         * @name SearchForCollection
         * @summary Search for a collection/category
         * @request GET:/v1/public/collection
         */
        searchForCollection: (
            query: {
                /**
                 * SEO Name of the collection to search for
                 * @example 182973198273912
                 */
                seoName: string;
                /** @example true */
                generateExtensions?: boolean;
            },
            params: RequestParams = {}
        ) =>
            this.request<Collection, void>({
                path: `/v1/public/collection`,
                method: "GET",
                query: query,
                format: "json",
                ...params,
            }),

        /**
         * @description Searches the catalogue for a collection with a matching SEO name/code, then triggers the extension framework
         *
         * @tags Collections
         * @name HandleCollectionExtension
         * @summary Handle extension submissions for a collection/category
         * @request POST:/v1/public/collection/extension/{extensionId}
         */
        handleCollectionExtension: (
            extensionId: string,
            query: {
                /**
                 * SEO Name of the collection to search for
                 * @example 182973198273912
                 */
                seoName: string;
            },
            params: RequestParams = {}
        ) =>
            this.request<Collection, void>({
                path: `/v1/public/collection/extension/${extensionId}`,
                method: "POST",
                query: query,
                format: "json",
                ...params,
            }),

        /**
         * @description Fetches the products that are members of a collection specified by the ID in the URL
         *
         * @tags Collections, Products
         * @name GetProductsInCollection
         * @summary Get the products contained in a collection
         * @request GET:/v1/public/collection/{id}/products
         */
        getProductsInCollection: (
            id: string,
            query?: {
                /**
                 * The number of results to return in a page. If it isn't specified then a configured default will be returned.
                 * @example 20
                 */
                pageSize?: number;
                /**
                 * The page of results to be returned, with a 0-based index (i.e. the first page is page 0, then page 1, 2, etc.).  Defaults to 0 if not supplied.
                 * @example 1
                 */
                pageNumber?: number;
            },
            params: RequestParams = {}
        ) =>
            this.request<Product[], void>({
                path: `/v1/public/collection/${id}/products`,
                method: "GET",
                query: query,
                format: "json",
                ...params,
            }),

        /**
         * @description Creates a new product in the default catalogue associated with the site. (any ID passed will be ignored as it's creating a new product)
         *
         * @tags Admin
         * @name CreateNewProduct
         * @summary Creates a new product in the catalogue
         * @request POST:/v1/admin/product
         */
        createNewProduct: (
            data: Product,
            query?: {
                /**
                 * An override catalogue ID to allow products to be added to the non-default catalogue.
                 * @example "winter2022"
                 */
                catalogueId?: string;
            },
            params: RequestParams = {}
        ) =>
            this.request<Product, DuplicateIdentifierError | void>({
                path: `/v1/admin/product`,
                method: "POST",
                query: query,
                body: data,
                type: ContentType.Json,
                format: "json",
                ...params,
            }),

        /**
         * @description Updates a product in the default catalogue associated with the site.
         *
         * @tags Admin
         * @name UpdateProduct
         * @summary Updates a product in the catalogue
         * @request PUT:/v1/admin/product/{id}
         */
        updateProduct: (
            id: string,
            data: Product,
            query?: {
                /**
                 * An override catalogue ID to allow products to be updated in the non-default catalogue.
                 * @example "winter2022"
                 */
                catalogueId?: string;
            },
            params: RequestParams = {}
        ) =>
            this.request<Product, void>({
                path: `/v1/admin/product/${id}`,
                method: "PUT",
                query: query,
                body: data,
                type: ContentType.Json,
                format: "json",
                ...params,
            }),

        /**
         * @description Updates a product in the default catalogue associated with the site.
         *
         * @tags Admin
         * @name UpdateProductBySkuId
         * @summary Updates a product in the catalogue
         * @request PUT:/v1/admin/product/sku/{skuId}
         */
        updateProductBySkuId: (
            skuId: string,
            data: Product,
            query?: {
                /**
                 * An override catalogue ID to allow products to be updated in the non-default catalogue.
                 * @example "winter2022"
                 */
                catalogueId?: string;
            },
            params: RequestParams = {}
        ) =>
            this.request<Product, void>({
                path: `/v1/admin/product/sku/${skuId}`,
                method: "PUT",
                query: query,
                body: data,
                type: ContentType.Json,
                format: "json",
                ...params,
            }),

        /**
         * @description Creates a new product variant in the default catalogue associated with the site.
         *
         * @tags Admin
         * @name CreateNewProductVariant
         * @summary Creates a new product variant in the catalogue as a child of the parent product
         * @request POST:/v1/admin/product/{id}/variant
         */
        createNewProductVariant: (
            id: string,
            data: Product,
            query?: {
                /**
                 * An override catalogue ID to allow products to be added to the non-default catalogue.
                 * @example "winter2022"
                 */
                catalogueId?: string;
            },
            params: RequestParams = {}
        ) =>
            this.request<Product, DuplicateIdentifierError | void>({
                path: `/v1/admin/product/${id}/variant`,
                method: "POST",
                query: query,
                body: data,
                type: ContentType.Json,
                format: "json",
                ...params,
            }),

        /**
         * @description Retrieve product details from the current catalogue associated with the site
         *
         * @tags Products
         * @name QueryProducts
         * @summary retrieve a product by various query parameters
         * @request GET:/v1/public/product
         */
        queryProducts: (
            query?: {
                /**
                 * UPC of the product to search for
                 * @example 10412312321
                 */
                upc?: string;
                /** @example true */
                seoName?: string;
                /**
                 * Page of results to return. Defaults to 1 (which is the first)
                 * @format integer
                 * @example 1
                 */
                pageNumber?: number;
                /**
                 * Number of results to return in each page
                 * @format integer
                 * @example 10
                 */
                pageSize?: number;
            },
            params: RequestParams = {}
        ) =>
            this.request<Product[], void>({
                path: `/v1/public/product`,
                method: "GET",
                query: query,
                format: "json",
                ...params,
            }),

        /**
         * @description Retrieve product details from the current catalogue associated with the site
         *
         * @tags Products
         * @name GetProductBySku
         * @summary retrieve a product by sku code
         * @request GET:/v1/public/product/{productSkuCode}
         */
        getProductBySku: (
            productSkuCode: string,
            query?: {
                /** @example true */
                generateExtensions?: boolean;
            },
            params: RequestParams = {}
        ) =>
            this.request<Product, void>({
                path: `/v1/public/product/${productSkuCode}`,
                method: "GET",
                query: query,
                format: "json",
                ...params,
            }),

        /**
         * @description Regenerates the data for the product based upon the action provided by the element within the page.
         *
         * @tags Products
         * @name ProcessProductExtensionUpdate
         * @summary Handle an upadte from an extension
         * @request POST:/v1/public/product/{productSkuCode}/extension/{extensionId}
         */
        processProductExtensionUpdate: (productSkuCode: string, extensionId: string, data: ExtensionUpdateBody, params: RequestParams = {}) =>
            this.request<Product, void>({
                path: `/v1/public/product/${productSkuCode}/extension/${extensionId}`,
                method: "POST",
                body: data,
                type: ContentType.Json,
                format: "json",
                ...params,
            }),

        /**
         * @description Creates a new user in the Badger Datastore
         *
         * @tags User
         * @name CreateUser
         * @summary Create a new user
         * @request POST:/v1/user
         * @secure
         */
        createUser: (params: RequestParams = {}) =>
            this.request<void, void>({
                path: `/v1/user`,
                method: "POST",
                secure: true,
                ...params,
            }),

        /**
         * @description Removes the current users details from the Badger Datastore (basically unregister/forget).
         *
         * @tags User
         * @name DeleteUser
         * @summary Remove a user
         * @request DELETE:/v1/user
         * @secure
         */
        deleteUser: (params: RequestParams = {}) =>
            this.request<void, void>({
                path: `/v1/user`,
                method: "DELETE",
                secure: true,
                ...params,
            }),

        /**
         * @description Retrieve the user data held in Badger about the logged in customer. The user is resolved from the JWT token passed into the call. Providing you have a token you can expect this to always return a user, whether anonymous or not.
         *
         * @tags User
         * @name FindUser
         * @summary Get user
         * @request GET:/v1/user
         * @secure
         */
        findUser: (params: RequestParams = {}) =>
            this.request<User, void>({
                path: `/v1/user`,
                method: "GET",
                secure: true,
                format: "json",
                ...params,
            }),

        /**
         * @description Creates a token for a user that can be used to merge this user with another
         *
         * @tags User
         * @name CreateMergeToken
         * @summary Create a secure merge token
         * @request POST:/v1/user/merge/token
         * @secure
         */
        createMergeToken: (params: RequestParams = {}) =>
            this.request<string, void>({
                path: `/v1/user/merge/token`,
                method: "POST",
                secure: true,
                format: "json",
                ...params,
            }),

        /**
         * @description Merges another user (based on the merge token passed in) with the currently authenticated user, and de-activates the other user within the badger data store
         *
         * @tags User
         * @name MergeUsers
         * @summary Merges the user
         * @request PUT:/v1/user/merge
         * @secure
         */
        mergeUsers: (
            query: {
                /** @example "8913407123847012934:asdsdasdas" */
                mergeToken: string;
            },
            params: RequestParams = {}
        ) =>
            this.request<void, void>({
                path: `/v1/user/merge`,
                method: "PUT",
                query: query,
                secure: true,
                ...params,
            }),

        /**
         * @description Gets orders for the site
         *
         * @tags Admin
         * @name RetrieveOrders
         * @summary Gets orders
         * @request GET:/v1/admin/orders
         * @secure
         */
        retrieveOrders: (
            query?: {
                /**
                 * The number of results to return in a page. If it isn't specified then a default number will be returned.
                 * @example 200
                 */
                pageSize?: number;
                /**
                 * The  page of results to be returned, with a 0-based index (i.e. the first page is page 0, then page 1, 2, etc.). Defaults to 0 if not supplied.
                 * @example 1
                 */
                pageNumber?: number;
                /** Email address of the user used to filter the results to only those */
                customerEmail?: string;
                /** Status of the items that should be returneds */
                state?: "new" | "inflight" | "completed" | "cancelled";
            },
            params: RequestParams = {}
        ) =>
            this.request<OrderSearchResults, any>({
                path: `/v1/admin/orders`,
                method: "GET",
                query: query,
                secure: true,
                format: "json",
                ...params,
            }),

        /**
         * @description Gets users for the site
         *
         * @tags Admin
         * @name RetrieveUsers
         * @summary Gets user
         * @request GET:/v1/admin/users
         * @secure
         */
        retrieveUsers: (
            query?: {
                /**
                 * The number of results to return in a page. If it isn't specified then a default number will be returned.
                 * @example 200
                 */
                pageSize?: number;
                /**
                 * The  page of results to be returned, with a 0-based index (i.e. the first page is page 0, then page 1, 2, etc.). Defaults to 0 if not supplied.
                 * @example 1
                 */
                pageNumber?: number;
                /** Type of user to return. Defaults to all */
                orderType?: "anonymous" | "registered" | "anonOrders" | "all";
            },
            params: RequestParams = {}
        ) =>
            this.request<Order[], any>({
                path: `/v1/admin/users`,
                method: "GET",
                query: query,
                secure: true,
                format: "json",
                ...params,
            }),

        /**
         * @description gets the user's current basket. If one doesn't exist, a transient one will be returned
         *
         * @tags Order
         * @name RetrieveCurrentBasket
         * @summary Gets the current basket
         * @request GET:/v1/basket
         * @secure
         */
        retrieveCurrentBasket: (
            query?: {
                /**
                 * Determines whether the product level information should be included in the response
                 * @example true
                 */
                retrieveProducts?: boolean;
            },
            params: RequestParams = {}
        ) =>
            this.request<Order, any>({
                path: `/v1/basket`,
                method: "GET",
                query: query,
                secure: true,
                format: "json",
                ...params,
            }),

        /**
         * @description This operation will create a basket for the user if one doesn't already exist, and will add the product and trigger a reprice of the order (along with any promotions that may apply)
         *
         * @tags Order
         * @name AddToBasket
         * @summary Adds a product to the user's current basket
         * @request PUT:/v1/basket
         * @secure
         */
        addToBasket: (
            data: AddToBasketRequest,
            query?: {
                /**
                 * Determines whether the product level information should be included in the response
                 * @example true
                 */
                retrieveProducts?: boolean;
                /**
                 * Controls whether the added product should be created as a separate line item, or whether the quantity of any existing line items of the same product can be updated. If no value is passed, it will default to the behaviour configured for the site.
                 * @example true
                 */
                forceNewLineItem?: boolean;
                /**
                 * Determines that the product being added is a take away item, which means that no fulfilment is required for this item as the customer has taken it at the point of sale (i.e. a POS transaction)
                 * @example true
                 */
                takeAwayItem?: boolean;
            },
            params: RequestParams = {}
        ) =>
            this.request<Order, any>({
                path: `/v1/basket`,
                method: "PUT",
                query: query,
                body: data,
                secure: true,
                type: ContentType.Json,
                format: "json",
                ...params,
            }),

        /**
         * @description This operation will create a basket for the user if one doesn't already exist, and will add the products, and trigger a reprice of the order (along with any promotions that may apply). The basket can be optionally persisted if required, or purely held in memory for the life of the request.
         *
         * @tags Order, Pricing
         * @name CreateNewBasket
         * @summary Creates a new basket of products and triggers a price and promotion calculation of the contents
         * @request POST:/v1/basket
         * @secure
         */
        createNewBasket: (
            data: CreateBasketRequest,
            query?: {
                /**
                 * Determines whether the product level information should be included in the response
                 * @example true
                 */
                retrieveProducts?: boolean;
                /**
                 * Sets this new basket as the user's current basket. Setting this to true means the basket is persisted regardless of the transientBasket property.
                 * @example true
                 */
                associateWithUser?: boolean;
                /**
                 * Determines whether the basket is persisted to the DB or not
                 * @example true
                 */
                transientBasket?: boolean;
                /**
                 * Allows the API to return without completing the pricing operation. Setting this value means the order will be persisted (as the reference returned must be used to retrieve the outcome of the operation in a subsequent call)
                 * @example true
                 */
                async?: boolean;
            },
            params: RequestParams = {}
        ) =>
            this.request<Order, any>({
                path: `/v1/basket`,
                method: "POST",
                query: query,
                body: data,
                secure: true,
                type: ContentType.Json,
                format: "json",
                ...params,
            }),

        /**
         * @description This operation will remove the user's basket
         *
         * @tags Order
         * @name DeleteBasket
         * @summary Delete current basket
         * @request DELETE:/v1/basket
         * @secure
         */
        deleteBasket: (params: RequestParams = {}) =>
            this.request<void, any>({
                path: `/v1/basket`,
                method: "DELETE",
                secure: true,
                ...params,
            }),

        /**
         * @description gets a specific basket for the user. If one doesn't exist, a transient one will be returned
         *
         * @tags Order
         * @name RetrieveBasketById
         * @summary Gets a basket by ID
         * @request GET:/v1/basket/{basketId}
         * @secure
         */
        retrieveBasketById: (basketId: string, params: RequestParams = {}) =>
            this.request<Order, void>({
                path: `/v1/basket/${basketId}`,
                method: "GET",
                secure: true,
                format: "json",
                ...params,
            }),

        /**
         * @description gets a specific basket for the user and returns the
         *
         * @tags Order
         * @name UpdatePersonalDetails
         * @summary Updates the personal details within an order
         * @request PATCH:/v1/basket/{basketId}/personalDetails
         * @secure
         */
        updatePersonalDetails: (basketId: string, data: UpdatePersonalDetails, params: RequestParams = {}) =>
            this.request<void, void>({
                path: `/v1/basket/${basketId}/personalDetails`,
                method: "PATCH",
                body: data,
                secure: true,
                type: ContentType.Json,
                ...params,
            }),

        /**
         * @description gets a specific basket for the user and returns the
         *
         * @tags Order
         * @name UpdateLineItem
         * @summary Updates a line item within an order
         * @request PATCH:/v1/basket/{basketId}/{lineItemId}
         * @secure
         */
        updateLineItem: (basketId: string, lineItemId: string, data: ModifyLineItemBody, params: RequestParams = {}) =>
            this.request<Order, void>({
                path: `/v1/basket/${basketId}/${lineItemId}`,
                method: "PATCH",
                body: data,
                secure: true,
                type: ContentType.Json,
                format: "json",
                ...params,
            }),

        /**
         * @description gets a specific basket for the user. If one doesn't exist, a transient one will be returned
         *
         * @tags Order
         * @name RemoveLineItem
         * @summary Removes a line item within an order
         * @request DELETE:/v1/basket/{basketId}/{lineItemId}
         * @secure
         */
        removeLineItem: (basketId: string, lineItemId: string, params: RequestParams = {}) =>
            this.request<Order, void>({
                path: `/v1/basket/${basketId}/${lineItemId}`,
                method: "DELETE",
                secure: true,
                format: "json",
                ...params,
            }),

        /**
         * @description Depending on the serverside configuration, this can trigger a number of operations (e.g. authorise payment, capture payment, start fulfilment, record transaction etc.). However this operation at a high level signifies the end of the customer's interaction with the order, and an acceptance of the order for processing by the system
         *
         * @tags Checkout
         * @name SubmitOrder
         * @summary Submits the order for processing
         * @request PUT:/v1/basket/{basketId}/submit
         * @secure
         */
        submitOrder: (basketId: string, params: RequestParams = {}) =>
            this.request<void, void>({
                path: `/v1/basket/${basketId}/submit`,
                method: "PUT",
                secure: true,
                ...params,
            }),

        /**
         * @description Updates the payment intent on the order specified by the ID
         *
         * @tags Checkout
         * @name UpdatePaymentIntent
         * @summary Updates the payment intent
         * @request PATCH:/v1/basket/{basketId}/paymentIntent/{intentId}
         * @secure
         */
        updatePaymentIntent: (basketId: string, intentId: string, data: PaymentIntent, params: RequestParams = {}) =>
            this.request<PaymentIntent, void>({
                path: `/v1/basket/${basketId}/paymentIntent/${intentId}`,
                method: "PATCH",
                body: data,
                secure: true,
                type: ContentType.Json,
                format: "json",
                ...params,
            }),

        /**
         * @description Gets the payment intent attached to the order if present
         *
         * @tags Checkout
         * @name GetPaymentIntentById
         * @summary Get payment intent by ID
         * @request GET:/v1/basket/{basketId}/paymentIntent/{intentId}
         * @secure
         */
        getPaymentIntentById: (basketId: string, intentId: string, params: RequestParams = {}) =>
            this.request<PaymentIntent, void>({
                path: `/v1/basket/${basketId}/paymentIntent/${intentId}`,
                method: "GET",
                secure: true,
                format: "json",
                ...params,
            }),

        /**
         * @description Retrieves all the payment intents attached to the given order
         *
         * @tags Checkout
         * @name GetAllPaymentIntents
         * @summary Returns all the payment intents
         * @request GET:/v1/basket/{basketId}/paymentIntent
         * @secure
         */
        getAllPaymentIntents: (basketId: string, params: RequestParams = {}) =>
            this.request<PaymentIntent[], void>({
                path: `/v1/basket/${basketId}/paymentIntent`,
                method: "GET",
                secure: true,
                format: "json",
                ...params,
            }),

        /**
         * @description Creates a new payment intent with the backend and returns the newly created value
         *
         * @tags Checkout
         * @name AddPaymentIntent
         * @summary Create payment intent and add it to the order
         * @request POST:/v1/basket/{basketId}/paymentIntent
         * @secure
         */
        addPaymentIntent: (
            basketId: string,
            query: {
                /**
                 * The amount of money that the intent should be created to capture. If this value is not supplied then the system will assume it should capture all remaining required balance for the order.
                 * @example 10000
                 */
                amount?: number;
                /** The type of payment intent that should be created. */
                paymentType: PaymentType;
            },
            params: RequestParams = {}
        ) =>
            this.request<PaymentIntent, void>({
                path: `/v1/basket/${basketId}/paymentIntent`,
                method: "POST",
                query: query,
                secure: true,
                format: "json",
                ...params,
            }),

        /**
         * @description Removes all payments from the order that are not in a captured state.
         *
         * @tags Checkout
         * @name RemoveAllPayments
         * @summary Removes all current payments on the order
         * @request DELETE:/v1/basket/{basketId}/paymentIntent
         * @secure
         */
        removeAllPayments: (basketId: string, params: RequestParams = {}) =>
            this.request<void, void>({
                path: `/v1/basket/${basketId}/paymentIntent`,
                method: "DELETE",
                secure: true,
                ...params,
            }),

        /**
         * @description Generates a secure auth token for the payment device in the location specified in the URL.
         *
         * @tags POS
         * @name GeneratePosPaymentToken
         * @summary Returns an authorisation token for a POS Payment system
         * @request GET:/v1/pos/{locationId}/paymentToken
         * @secure
         */
        generatePosPaymentToken: (locationId: string, params: RequestParams = {}) =>
            this.request<PaymentToken, void>({
                path: `/v1/pos/${locationId}/paymentToken`,
                method: "GET",
                secure: true,
                format: "json",
                ...params,
            }),
    };
}
